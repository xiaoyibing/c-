# 栈和队列

## 栈

栈（Stack）是计算机科学中一种常见的数据结构，它遵循后进先出（LIFO，Last In First Out）的原则。栈可以被认为是一种特殊的线性表，具有两个主要操作：压栈（Push）和出栈（Pop）。

**定义栈**

```c
#include <stdio.h>
#define MAX_SIZE 100

// 定义栈结构
typedef struct {
    int data[MAX_SIZE];
    int top; // 栈顶指针
} Stack;
```



- **初始化栈**

- ```c
  // 初始化栈
  void initStack(Stack *stack) {
      stack->top = -1; // 栈顶指针初始化为-1，表示空栈
  }
  ```

  

- **压栈（Push）操作：** 将一个元素放入栈顶。新元素被添加到栈的顶部，成为新的栈顶元素。

- ```c
  // 入栈操作
  void push(Stack *stack, int value) {
      if (stack->top == MAX_SIZE - 1) {
          printf("Error: Stack overflow\n");
          return;
      }
      stack->data[++(stack->top)] = value; // 栈顶指针先加1，再将元素入栈
  }
  ```

  

- **出栈（Pop）操作：** 从栈顶移除一个元素。栈顶元素被移除，同时栈顶指针指向下一个元素。

除了基本的压栈和出栈操作之外，栈还通常具有以下特性：

```c
// 出栈操作
int pop(Stack *stack) {
    if (stack->top == -1) {
        printf("Error: Stack underflow\n");
        return -1; // 栈空，返回一个特殊值表示出错
    }
    return stack->data[(stack->top)--]; // 先将栈顶元素出栈，再将栈顶指针减1
}
```



1. **栈顶指针（Top）：** 指向栈顶元素的指针。对于一个非空栈，栈顶指针指向栈中最后压入的元素。

```c
// 获取栈顶元素
int peek(Stack *stack) {
    if (stack->top == -1) {
        printf("Error: Stack is empty\n");
        return -1; // 栈空，返回一个特殊值表示出错
    }
    return stack->data[stack->top]; // 返回栈顶元素的值
}
```



1. **栈空（Empty）：** 如果栈中没有元素，则称为空栈。

2. ```c
   // 检查栈是否为空
   int isEmpty(Stack *stack) {
       return stack->top == -1; // 栈空的条件是栈顶指针为-1
   }
   ```

   

3. **栈满（Full）：** 如果栈中的元素数量达到了预先设定的最大容量，则称为满栈。在一些实现中，栈可能有容量限制，当栈满时，无法再执行压栈操作。

```c
// 检查栈是否已满
int isFull(Stack *stack) {
    return stack->top == MAX_SIZE - 1; // 栈满的条件是栈顶指针等于最大容量减1
}
```

栈在计算机科学中有广泛的应用，包括但不限于：

- 函数调用和返回的参数传递和局部变量的存储；
- 程序执行时的运算符优先级和表达式求值；
- 内存分配和管理；
- 后退和撤销功能的实现等。

在 C 语言中，栈通常通过数组或链表实现。例如，使用数组实现的栈可以轻松地在内存中分配一块连续的区域来存储数据，并使用一个指针来指示当前栈顶位置。



函数调用和返回、中缀表达式转换为后缀表达式、后缀表达式求值、表达式求解、深度优先搜索（DFS）、括号匹配、后退和撤销功能的实现等。栈的特性使得它非常适合于解决需要“先进后出”的问题。

## 队列

队列（Queue）是一种常见的数据结构，具有以下主要功能：

**初始化**

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

// 定义队列结构
typedef struct {
    int data[MAX_SIZE];
    int front; // 队头指针
    int rear;  // 队尾指针
} Queue;

// 初始化队列
void initQueue(Queue *queue) {
    queue->front = 0; // 队头指针初始化为0
    queue->rear = -1; // 队尾指针初始化为-1
}
```



1. **入队（Enqueue）：** 将一个元素放入队列尾部。新元素被添加到队列的末尾，成为新的队尾元素。

2. ```c
   // 入队操作
   void enqueue(Queue *queue, int value) {
       if (queue->rear == MAX_SIZE - 1) {
           printf("Error: Queue is full\n");
           return;
       }
       queue->data[++(queue->rear)] = value; // 队尾指针先加1，再将元素入队
   }
   ```

   

3. **出队（Dequeue）：** 从队列头部移除一个元素。队头元素被移除，同时队列头指针指向下一个元素。

```c
// 出队操作
int dequeue(Queue *queue) {
    if (queue->front > queue->rear) {
        printf("Error: Queue is empty\n");
        return -1; // 队空，返回一个特殊值表示出错
    }
    return queue->data[(queue->front)++]; // 先将队头元素出队，再将队头指针加1
}
```



1. **获取队头元素（Front）：** 获取队列头部的元素的值，但不对队列进行修改。这个操作只是查看队头元素，而不会从队列中移除它。

```c
// 获取队头元素
int front(Queue *queue) {
    if (queue->front > queue->rear) {
        printf("Error: Queue is empty\n");
        return -1; // 队空，返回一个特殊值表示出错
    }
    return queue->data[queue->front]; // 返回队头元素的值
}
```



1. **获取队尾元素（Rear）：** 获取队列尾部的元素的值，但不对队列进行修改。这个操作只是查看队尾元素，而不会从队列中移除它。



1. **检查队列空（isEmpty）：** 判断队列是否为空。如果队列中没有元素，则称为为空队列。

2. ```c
   // 检查队列是否为空
   int isEmpty(Queue *queue) {
       return queue->front > queue->rear; // 队空的条件是队头指针大于队尾指针
   }
   ```

   

3. **检查队列满（isFull）：** 判断队列是否已满。如果队列中的元素数量达到了预先设定的最大容量，则称为满队列。

4. **清空队列（Clear）：** 将队列中的所有元素移除，使队列恢复为空状态。

5. ```c
   // 清空队列
   void clearQueue(Queue *queue) {
       queue->front = 0; // 队头指针重置为0
       queue->rear = -1; // 队尾指针重置为-1
   }
   ```

   

6. **获取队列的大小（Size）：** 获取队列中元素的数量。

7. ```c
   // 获取队列大小
   int size(Queue *queue) {
       return queue->rear - queue->front + 1; // 队列大小等于队尾指针减去队头指针加1
   }
   ```

   

8. **复制队列（Copy）：** 将一个队列的所有元素复制到另一个队列中。

队列通常以先进先出（FIFO，First In First Out）的方式组织元素，即最先入队的元素最先出队。这种特性使得队列非常适合于解决需要“先进先出”的问题，例如任务调度、消息传递、缓冲区管理等。在计算机科学中，队列有着广泛的应用，包括操作系统中的进程调度、网络通信中的数据传输、图论算法中的广度优先搜索（BFS）等。



## 后缀表达式

中缀表达式、前缀表达式和后缀表达式是表示数学表达式的三种形式，它们之间的区别在于运算符的位置。

1. **中缀表达式：** 中缀表达式是最常见的数学表达式形式，其中运算符位于操作数的中间。例如：`(A + B) * C`。
2. **前缀表达式（前缀记法或波兰式）：** 前缀表达式中运算符位于操作数的前面。例如：`* + A B C`。前缀表达式的计算通常需要使用栈来实现。
3. **后缀表达式（后缀记法或逆波兰式）：** 后缀表达式中运算符位于操作数的后面。例如：`A B + C *`。后缀表达式的计算也通常需要使用栈来实现。



--------



#### 中缀转后缀

1. **创建一个空栈来存储运算符。**
2. **从左到右遍历中缀表达式中的每个字符。**
3. **如果当前字符是操作数（数字或变量），则直接将其输出到后缀表达式中。**
4. **如果当前字符是左括号 (，则将其压入栈中。**
5. **如果当前字符是右括号 )，则从栈中弹出并输出所有运算符，直到遇到左括号为止。**
6. **如果当前字符是运算符，比较其与栈顶运算符的优先级：**
   - 如果栈为空或栈顶运算符是左括号，则将当前运算符压入栈中。
   - 如果当前运算符的优先级高于栈顶运算符，则将当前运算符压入栈中。
   - 如果当前运算符的优先级低于或等于栈顶运算符，则从栈中弹出并输出栈顶运算符，直到栈顶运算符的优先级低于当前运算符，或栈为空，然后将当前运算符压入栈中。
7. **重复步骤 3 到步骤 6，直到处理完所有字符。**
8. **将栈中剩余的运算符依次弹出并输出到后缀表达式中。**
9. **后缀表达式即为中缀表达式的转换结果。**



------



#### 后缀表达式的求值

1. **创建一个空栈来存储操作数。**
2. **从左到右遍历后缀表达式中的每个字符。**
3. **如果当前字符是操作数（数字），则将其转换为相应的数值并压入栈中。**
4. **如果当前字符是运算符，从栈中弹出相应数量的操作数进行运算，并将结果压入栈中。**
   - 对于二元运算符，从栈中弹出两个操作数进行运算。
   - 对于一元运算符（例如负号），从栈中弹出一个操作数进行运算。
5. **重复步骤 3 和步骤 4，直到处理完所有字符。**
6. **最终栈中只剩下一个元素，即为后缀表达式的计算结果。**