# c语言笔记

## 一，介绍

### 优点

1. **高效性：** C语言是一种底层语言，允许对计算机硬件进行直接的操作和控制，因此具有高效性。它可以直接访问内存和硬件，提供了更好的性能和控制。
2. **可移植性：** C语言的编译器和标准库在许多平台上都有很好的支持，使得编写的C代码可以轻松地移植到不同的系统上运行，这增加了代码的可重用性。
3. **广泛应用：** 许多操作系统和嵌入式系统都是用C语言编写的，因此它具有广泛的应用领域，包括系统编程、驱动程序开发、游戏开发等。
4. **简洁而灵活：** C语言的语法相对简单，并且提供了丰富的指针操作，使得程序员可以编写出高效而灵活的代码。
5. **丰富的库支持：** 虽然C语言的标准库相对较小，但是存在许多第三方库可以扩展其功能，例如网络编程、图形界面开发、加密等方面。

### 缺点

1. **内存管理问题：** C语言中使用指针进行内存管理时容易出现错误，例如内存泄漏、悬挂指针等问题，需要程序员手动管理内存。
2. **缺乏安全性：** C语言对越界访问数组、空指针解引用等错误缺乏足够的检查，容易导致程序崩溃或安全漏洞。
3. **不适合大型项目：** C语言缺乏面向对象编程的特性，不够适应大型项目的复杂性和维护性要求，容易导致代码的混乱和难以维护。
4. **相对较低的抽象级别：** C语言是一种较为底层的语言，需要程序员对计算机硬件有较深的了解，编写的代码相对较为繁琐，不够抽象。
5. **缺乏现代特性：** 相对于一些现代编程语言（如Python、Java、C#等），C语言缺乏许多现代特性，例如垃圾回收、异常处理、泛型等，使得编程效率相对较低。

### 一些规范

一个规范的 C 语言程序应该注意以下几个要素：

1. **注释：** 良好的注释是一个好的习惯，能够提高代码的可读性。注释应该清晰地解释代码的功能、目的、输入、输出等信息。对于复杂的算法或特殊的代码逻辑，应当用注释来说明清楚。
2. **命名规范：** 变量名、函数名、宏定义等标识符应该命名具有意义，能够清晰地表达其用途。遵循命名规范，例如使用驼峰命名法或下划线命名法，并且避免使用过于简单或含糊不清的命名。
3. **缩进和格式化：** 适当的缩进和格式化可以提高代码的可读性。代码块应当按照逻辑结构进行缩进，使代码的层次结构清晰可见。推荐使用统一的缩进风格，例如使用 2 或 4 个空格进行缩进。
4. **函数模块化：** 将功能模块划分为函数，提高代码的可维护性和可重用性。每个函数应该具有清晰的功能和职责，并且尽可能地独立于其他函数。
5. **错误处理：** 合理处理错误和异常情况，避免程序崩溃或产生未定义的行为。对于可能出现错误的地方，应当进行适当的检查和处理，例如检查函数的返回值或输入参数的有效性。
6. **内存管理：** 合理地管理内存资源，避免内存泄漏和内存溢出。在动态内存分配时，应当及时释放已分配的内存，以防止资源浪费和程序性能下降。
7. **编译警告：** 注意编译器产生的警告信息，尽量消除所有警告。警告通常表示代码中可能存在潜在的问题或不规范的写法，应该仔细检查并进行修正。
8. **代码重构：** 定期对代码进行重构，提高代码的质量和可维护性。删除冗余代码、优化性能、简化逻辑等操作，使代码更加简洁、清晰和易于理解。
9. **文档：** 编写适当的文档，包括代码注释、函数文档、接口文档等。文档应该描述代码的用途、使用方法、输入输出、限制条件等信息，有助于其他开发人员理解和使用代码。
10. **遵循标准：** 遵循 C 语言的编程标准和最佳实践，例如遵循 ANSI C 标准、避免使用未定义行为、避免依赖于特定编译器行为等。

11. **友好的用户界面**

## 二，头文件

在C语言中，头文件（Header file）是一种包含函数声明、宏定义、类型定义等信息的文本文件，通常以“.h”作为文件扩展名。头文件通常用于存放程序中各种函数、变量、宏的声明，以便在多个源文件中共享这些声明，提高代码的可维护性和可重用性。

头文件主要包含以下内容：

1. **函数声明：** 头文件中通常包含函数的声明，包括函数的名称、参数列表和返回类型，但不包括函数的实现。这样可以在多个源文件中包含同一个头文件，以便调用其中声明的函数。
2. **变量声明：** 头文件中也可以包含全局变量的声明，以及外部变量的声明。这些变量的定义通常在源文件中进行，而头文件中只包含其声明。
3. **宏定义：** 头文件中经常包含宏定义，例如常量定义、条件编译指令等，以提高代码的可读性和灵活性。
4. **类型定义：** 头文件中可能包含自定义类型的声明，例如结构体、枚举类型等，以便在多个源文件中共享这些类型。

## 三，=

等号 `=` 是赋值运算符，用于将一个值赋给一个变量。它的作用是将等号右侧的表达式的值赋给等号左侧的变量。

1. **右值赋给左值：** 赋值运算符 `=` 将右侧的表达式的值赋给左侧的变量。例如：`x = 5;` 将整数值 `5` 赋给变量 `x`。
2. **表达式的值：** 赋值运算符的结果是赋给左边变量的值，也就是赋值后的左边变量的值。例如：`x = y = 10;` 这个表达式将使 `y` 被赋值为 `10`，然后将 `y` 的值赋给 `x`，因此 `x` 的值也是 `10`。
3. **赋值链：** 多个赋值运算符可以连续使用，形成赋值链，但要注意赋值的优先级和结合性。例如，`x = y = 10;` 就是一个赋值链。
4. **顺序性：** 赋值运算符是从右到左结合的，因此表达式 `x = y = 10;` 会先计算右边的 `y = 10;`，然后将其结果赋给 `x`。
5. **数据类型匹配：** 赋值运算符两侧的数据类型需要匹配，否则会进行隐式类型转换或者产生编译错误。
6. **赋值表达式：** 赋值运算符可以作为表达式的一部分出现，例如在条件语句、循环语句、函数调用等中使用。

## 四，数据类型

#### 1.整型

- `int`：常用整型，通常为32位（4字节），输出格式为`%d`，`%i`。
- `short`：短整型，通常为16位（2字节），输出格式为`%hd`，`%hi`。
- `long`：长整型，通常为32位或64位（4字节或8字节），输出格式为`%ld`，`%li`。
- `long long`：长长整型，通常为64位（8字节），输出格式为`%lld`，`%lli`。

#### 2.无符号整型

- `unsigned int`：无符号整型，与`int`具有相同的大小，但只能表示非负整数，输出格式为`%u`。
- `unsigned short`：无符号短整型，与`short`具有相同的大小，但只能表示非负整数，输出格式为`%hu`。
- `unsigned long`：无符号长整型，与`long`具有相同的大小，但只能表示非负整数，输出格式为`%lu`。
- `unsigned long long`：无符号长长整型，与`long long`具有相同的大小，但只能表示非负整数，输出格式为`%llu`。

#### 3.浮点型

- `float`：单精度浮点型，通常为32位（4字节），输出格式为`%f`。
- `double`：双精度浮点型，通常为64位（8字节），输出格式为`%lf`。
- `long double`：长双精度浮点型，通常为80位或128位（10字节或16字节），输出格式为`%Lf`。

#### 4.字符型

- `char`：字符型，通常为8位（1字节），输出格式为`%c`。

#### 5.派生类型

- `void`：空类型，用于函数返回类型或指针类型，无法直接输出。







#### _Bool类型

 它是C语言中的一种基本数据类型，只能存储0或1，其中0表示假（false），1表示真（true）







## 五，输出

**字符**

```c
char ch = 'A';
printf("%c\n", ch); // 输出：A
```

**字符串**

```c
char str[] = "Hello, world!";
printf("%s\n", str); // 输出：Hello, world!
```

**文件**

```c
FILE *file = fopen("output.txt", "w");
fprintf(file, "This is a message.\n");
fclose(file);
```

#### 转义字符

1. **\n**：换行符（Newline），用于在输出中换行。
2. **\t**：制表符（Tab），用于在输出中插入水平制表符。
3. **\r**：回车符（Carriage Return），将光标移到当前行的开头。
4. **\b**：退格符（Backspace），将光标向左移动一格，可以用于删除前一个字符。
5. **\\**：反斜杠（Backslash），用于表示反斜杠字符本身。
6. **\'**：单引号（Single Quote），用于表示单引号字符本身。
7. **\"**：双引号（Double Quote），用于表示双引号字符本身。
8. **\0**：空字符（Null Character），ASCII值为0的字符，用于表示字符串的结束。
9. **\xhh**：十六进制表示的字符，其中`hh`是一个或两个十六进制数字，用于表示一个特定的字符。

```c
printf("Hello\nWorld"); // 输出：
                         // Hello
                         // World

printf("This\tis\ta\ttab"); // 输出：This    is    a    tab

printf("Back\bSpace"); // 输出：BackSpace

printf("Quotes: \'single\' and \"double\""); // 输出：Quotes: 'single' and "double"
```

#### 修饰符

1. 宽度修饰符（Width Modifier）：
   - `%n`：最小字段宽度，指定输出字段的最小宽度。例如，`%5d`表示输出的整数字段至少为5个字符宽。
   - `%-n`：左对齐，指定输出字段左对齐，不足部分在右侧填充空格。例如，`%-5d`表示左对齐的整数字段，至少为5个字符宽。
   - `%n.m`：最小字段宽度和精度，指定输出字段的最小宽度和小数点后的位数。例如，`%8.2f`表示输出的浮点数字段至少为8个字符宽，且小数点后保留2位小数。
   - `%-n.m`：左对齐、最小字段宽度和精度，结合了上述两种修饰符的功能。
2. 精度修饰符（Precision Modifier）：
   - `.n`：精度，指定输出字段的小数点后的位数。例如，`%.2f`表示输出的浮点数字段保留2位小数。
3. 长度修饰符（Length Modifier）：
   - `h`：短整型，用于`%d`和`%u`等整型格式。例如，`%hd`表示输出的短整型。
   - `l`：长整型，用于`%d`和`%u`等整型格式。例如，`%ld`表示输出的长整型。
   - `L`：长双精度浮点型，用于`%f`等浮点型格式。例如，`%Lf`表示输出的长双精度浮点型。
4. 其他修饰符：
   - `+`：显示正负号，用于`%d`和`%f`等格式。例如，`%+d`表示输出带正负号的整数。
   - `#`：备用格式，用于`%o`、`%x`和`%e`等格式。例如，`%#o`表示以八进制形式输出整数，并在前面加上前缀`0`。
   - `0`：补零，用于`%d`、`%u`和`%x`等格式。例如，`%05d`表示输出的整数字段宽度为5，不足部分用零填充。



#### putchar() 函数

1.  `putchar()` 函数用于向标准输出流中输出一个字符。它将一个字符作为参数，并将其写入标准输出流。

```
cCopy code
#include <stdio.h>

int main() {
    char ch = 'A';

    printf("The character is: ");
    putchar(ch);
    printf("\n");

    return 0;
}
```





## 六，运算符

1. **算术运算符（Arithmetic Operators）：** 用于执行基本的数学运算。
   - `+`：加法
   - `-`：减法
   - `*`：乘法
   - `/`：除法
   - `%`：取模（取余数）
2. **关系运算符（Relational Operators）：** 用于比较两个值之间的关系。
   - `==`：等于
   - `!=`：不等于
   - `>`：大于
   - `<`：小于
   - `>=`：大于等于
   - `<=`：小于等于
3. **逻辑运算符（Logical Operators）：** 用于执行逻辑运算。
   - `&&`：逻辑与（AND）
   - `||`：逻辑或（OR）
   - `!`：逻辑非（NOT）
4. **位运算符（Bitwise Operators）：** 用于对二进制位进行操作。
   - `&`：按位与（AND）
   - `|`：按位或（OR）
   - `^`：按位异或（XOR）
   - `~`：按位取反（NOT）
   - `<<`：左移位
   - `>>`：右移位
5. **赋值运算符（Assignment Operators）：** 用于给变量赋值。
   - `=`：赋值
   - `+=`：加等于
   - `-=`：减等于
   - `*=`：乘等于
   - `/=`：除等于
   - `%=`：取模等于
   - `&=`：按位与等于
   - `|=`：按位或等于
   - `^=`：按位异或等于
   - `<<=`：左移位等于
   - `>>=`：右移位等于
6. **其他运算符：**
   - `sizeof`：返回数据类型或变量的大小（以字节为单位）
   - `&`：取地址运算符，返回变量的地址
   - `*`：指针运算符，用于指针变量的声明和间接引用
   - `?:`：条件运算符，用于简单的条件判断

#### **优先级由高到低**

1. **圆括号 ()：** 优先级最高，用于强制改变表达式的结合顺序。
2. **后缀递增和递减 ++、--：** 指定运算符的优先级高于其他大多数运算符。
3. **前缀递增和递减 ++、--：** 在操作数之前递增或递减。
4. **一元运算符 +、-、!、~：** 单目运算符，用于取反或改变数值的正负性。
5. **强制类型转换 ()：** 用于将表达式强制转换为指定的数据类型。
6. **乘法 \*、除法 /、取模 %：** 乘法、除法和取模运算。
7. **加法 +、减法 -：** 加法和减法运算。
8. **位移 <<、>>：** 左移和右移位运算。
9. **关系运算符 <、<=、>、>=：** 比较运算符，用于比较两个值的大小关系。
10. **相等运算符 ==、!=：** 等于和不等于运算符。
11. **按位与 &：** 按位与运算符。
12. **按位异或 ^：** 按位异或运算符。
13. **按位或 |：** 按位或运算符。
14. **逻辑与 &&：** 逻辑与运算符。
15. **逻辑或 ||：** 逻辑或运算符。
16. **条件运算符 ? :：** 三元条件运算符。
17. **赋值 =、+=、-=、\*=、/=、%=、&=、^=、|=、<<=、>>=：** 赋值运算符及其组合运算符。
18. **逗号 ,：** 用于分隔表达式，并按照从左到右的顺序进行计算。





#### sizeof

`sizeof` 是 C 语言中的一个运算符，用于计算数据类型或变量的大小（以字节为单位）。`sizeof` 运算符返回一个 `size_t` 类型的值，表示指定数据类型或变量所占用的存储空间大小。

1. 计算数据类型的大小：

```c
printf("Size of int: %zu bytes\n", sizeof(int));
printf("Size of char: %zu bytes\n", sizeof(char));
printf("Size of float: %zu bytes\n", sizeof(float));
```

1. 计算变量的大小：

```c
int num;
printf("Size of num: %zu bytes\n", sizeof(num));

float array[10];
printf("Size of array: %zu bytes\n", sizeof(array));
```

1. 计算指针的大小：

```c
int *ptr;
printf("Size of ptr: %zu bytes\n", sizeof(ptr));
```

需要注意的是，`sizeof` 运算符在编译时计算，返回的是数据类型或变量在当前编译环境中所占用的字节数。因此，`sizeof` 运算符的结果在不同的编译环境下可能会有所不同。

在实际编程中，`sizeof` 运算符通常用于动态内存分配、数组大小计算、结构体大小计算等场景中。



#### ++n和n++

1. **++n：** 先将变量 `n` 的值加 1，然后再使用增加后的值。这种方式叫做“前缀递增”，因为递增操作是在变量被使用之前执行的。
2. **n++：** 先使用变量 `n` 的当前值，然后再将其加 1。这种方式叫做“后缀递增”，因为递增操作是在变量被使用之后执行的。

```c
int n = 5;

// 前缀递增
printf("Before incrementing: %d\n", n);  // 输出：Before incrementing: 5
printf("During incrementing: %d\n", ++n); // 输出：During incrementing: 6
printf("After incrementing: %d\n", n);   // 输出：After incrementing: 6

// 后缀递增
printf("Before incrementing: %d\n", n);  // 输出：Before incrementing: 6
printf("During incrementing: %d\n", n++); // 输出：During incrementing: 6
printf("After incrementing: %d\n", n);   // 输出：After incrementing: 7
```



#### 类型转换

1. **隐式类型转换（Implicit Type Conversion）：** 也称为自动类型转换，是由编译器自动执行的类型转换，不需要程序员手动指定。隐式类型转换通常发生在表达式中，当运算符需要不同类型的操作数时，编译器会自动将其中一个操作数转换为另一个操作数的类型。例如：

```
int a = 10;
float b = 5.5;

float result = a + b; // 整数 a 隐式转换为浮点数，结果为浮点数 15.5
```

1. **显式类型转换（Explicit Type Conversion）：** 也称为强制类型转换，是由程序员手动指定的类型转换，使用强制类型转换运算符来实现。显式类型转换允许程序员将一个数据类型转换为另一个数据类型，即便这可能导致精度损失或数据截断。在 C 语言中，常见的显式类型转换运算符包括 `(type)` 和 `sizeof`。例如：

```
int a = 10;
double b = 5.5;

int result = (int)b + a; // 将浮点数 b 显式转换为整数，结果为整数 15
```

需要注意的是，显式类型转换可能会导致数据精度丢失或溢出，因此在使用时需要谨慎。



#### 逻辑运算符

**逻辑与 &&：** 逻辑与运算符用于判断两个条件是否同时成立，只有当两个条件都为真时，逻辑与运算的结果才为真。

**逻辑或 ||：** 逻辑或运算符用于判断两个条件是否至少有一个成立，只要有一个条件为真，逻辑或运算的结果就为真。

**逻辑非 !：** 逻辑非运算符用于对条件进行取反，如果条件为真，则逻辑非运算的结果为假；如果条件为假，则逻辑非运算的结果为真。

#### &&

```c
while(x++ < 10 && x+y <20)
```

在运算x+y时，已近运算了x++

计算范围

```c
#include <stdio.h>

int main() {
    char ch = 'a';

    if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')) {
        printf("The character is a letter.\n");
    } else {
        printf("The character is not a letter.\n");
    }

    return 0;
}
```



#### ？

在 C 语言中，`？` 是条件运算符（也称为三元运算符）。它是唯一一个需要三个操作数的运算符，其基本形式为：

```c
条件表达式 ? 表达式1 : 表达式2
```

它的运行原理是：首先计算条件表达式的值。如果条件表达式的值为真（非零），则整个表达式的值为 `表达式1` 的值；如果条件表达式的值为假（零），则整个表达式的值为 `表达式2` 的值。







## 七，typedef

`typedef` 是 C 语言中的一个关键字，用于创建新的数据类型别名。通过 `typedef` 关键字，可以为已有的数据类型定义一个新的名称，从而使得代码更易读和更具可移植性

```c
typedef 已有类型 新类型名;
```

除了简单的数据类型别名外，`typedef` 还可以用于创建复合类型别名，如结构体、枚举、指针等。

```c
typedef struct {
    int x;
    int y;
} Point;
```

例如，假设我们想要创建一个名为 `Color` 的新类型，表示颜色，我们可以使用 `typedef` 来为 `int` 类型创建这个新的类型：

```c
typedef int Color;

Color red = 0xFF0000;
Color blue = 0x0000FF;
```



## 八，循环



**for循环**

**while循环**

**do-while循环**

 `do-while` 循环是一种先执行循环体再判断条件的循环结构。它的基本语法如下：

```c
do {
    // 循环体
} while (条件);
```

`do-while` 循环的执行过程是：

- 首先执行循环体。
- 然后判断条件，如果条件为真（非零），则继续执行循环体；如果条件为假（零），则跳出循环。
- 再次判断条件，重复上述步骤，直到条件为假为止。

`do-while` 循环至少会执行一次循环体，即使条件一开始就为假。

例如，使用 `do-while` 循环计算 1 到 10 的累加和：

```c
int sum = 0;
int i = 1;
do {
    sum += i;
    i++;
} while (i <= 10);
printf("Sum: %d\n", sum); // 输出：Sum: 55
```

## 九，数组

数组（Array）是一种用于存储相同类型数据元素的集合，在 C 语言中被广泛使用。数组中的每个元素都具有相同的数据类型，并且可以通过索引来访问。在 C 语言中，数组的索引从 0 开始。

数组的基本语法如下：

```c
type arrayName[arraySize];
```

其中，`type` 是数组中元素的数据类型，`arrayName` 是数组的名称，`arraySize` 是数组的大小（元素个数）。

例如，定义一个包含 5 个整数的数组：

```c
int numbers[5];
```

上述代码定义了一个名为 `numbers` 的整型数组，它可以存储 5 个整数。数组的索引范围是 0 到 4，即 `numbers[0]` 到 `numbers[4]`。

数组的初始化可以在声明时进行，也可以在声明后的任意时刻进行。以下是一些数组的初始化示例：

```c
int numbers[5] = {1, 2, 3, 4, 5}; // 在声明时初始化数组
int primes[] = {2, 3, 5, 7, 11}; // 编译器自动推断数组大小
```

数组的元素可以通过索引访问和修改。例如：

```c
numbers[0] = 10; // 修改数组的第一个元素为 10
int x = numbers[2]; // 访问数组的第三个元素，并赋值给变量 x
```

在 C 语言中，数组是一种静态的数据结构，一旦定义了数组的大小，就不能再改变。数组的大小必须是一个常量表达式，不能是变量。数组的大小决定了在内存中所分配的空间大小，因此要谨慎确定数组的大小，以免发生内存溢出。





#### 动态数组

1. **使用 malloc() 函数创建动态数组：**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int size;
    printf("Enter size of array: ");
    scanf("%d", &size);

    // 使用 malloc() 函数动态分配内存
    int *arr = (int *)malloc(size * sizeof(int));

    if (arr == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // 使用动态数组
    for (int i = 0; i < size; i++) {
        arr[i] = i * 10;
    }

    // 释放动态分配的内存
    free(arr);

    return 0;
}
```

1. **使用 calloc() 函数创建动态数组：**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int size;
    printf("Enter size of array: ");
    scanf("%d", &size);

    // 使用 calloc() 函数动态分配内存
    int *arr = (int *)calloc(size, sizeof(int));

    if (arr == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // 使用动态数组
    for (int i = 0; i < size; i++) {
        arr[i] = i * 10;
    }

    // 释放动态分配的内存
    free(arr);

    return 0;
}
```

1. **使用 realloc() 函数调整动态数组大小：**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int size;
    printf("Enter initial size of array: ");
    scanf("%d", &size);

    // 使用 malloc() 函数动态分配内存
    int *arr = (int *)malloc(size * sizeof(int));

    if (arr == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // 使用动态数组
    for (int i = 0; i < size; i++) {
        arr[i] = i * 10;
    }

    // 调整动态数组大小
    printf("Enter new size of array: ");
    scanf("%d", &size);
    arr = (int *)realloc(arr, size * sizeof(int));

    if (arr == NULL) {
        printf("Memory reallocation failed\n");
        return 1;
    }

    // 使用动态数组
    for (int i = 0; i < size; i++) {
        arr[i] = i * 10;
    }

    // 释放动态分配的内存
    free(arr);

    return 0;
}
```

#### 数组传入函数

1. **传递数组的名称：** 在函数参数列表中声明数组参数时，可以直接使用数组的名称。在函数内部，数组参数会被当作指针来处理，即传递的是数组的地址。

```c
void func(int arr[], int size) {
    // 在函数内部使用数组
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);
    func(arr, size); // 传递数组给函数
    return 0;
}
```

1. **传递指针：** 可以将数组的指针作为函数参数传递，函数声明中参数的类型为指向数组元素的指针。这种方式与传递数组名称类似，实际上也是将数组的地址传递给函数。

```c
void func(int *arr, int size) {
    // 在函数内部使用数组
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);
    func(arr, size); // 传递数组的指针给函数
    return 0;
}
```

1. **传递指定长度的数组：** 在函数参数列表中，也可以指定数组的长度，这样函数就可以知道数组的大小。

```c
void func(int arr[5]) {
    // 在函数内部使用数组
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    func(arr); // 传递数组给函数
    return 0;
}
```





## 十，输入

#### getchar() 函数

 `getchar()` 函数用于从标准输入流中读取一个字符，并返回其 ASCII 码值。它通常与循环结合使用，用于逐字符地读取输入。

```c
#include <stdio.h>

int main() {
    char ch;

    printf("Enter a character: ");
    ch = getchar();

    printf("You entered: ");
    putchar(ch);
    printf("\n");

    return 0;
}
```

#### scanf() 函数

1. `scanf()` 函数是 C 语言中的格式化输入函数，用于从标准输入中读取数据并根据格式化字符串存储到指定的变量中。

```c
#include <stdio.h>

int main() {
    char ch;

    printf("Enter a character: ");
    scanf("%c", &ch);

    printf("You entered: ");
    putchar(ch);
    printf("\n");

    return 0;
}
```



## 十一，函数

#### exit（）

`exit()` 是 C 语言中的一个函数，用于终止程序的执行并退出。它通常在程序达到某个条件时调用，或者在程序出现错误时调用，以立即停止程序的运行。

`exit()` 函数位于 `stdlib.h` 头文件中，其原型如下：

```c
void exit(int status);
```

其中，`status` 参数表示程序的退出状态，通常情况下，0 表示程序正常退出，非 0 值表示程序异常退出或错误状态。在 C 语言中，`exit(0)` 是默认的正常退出状态。

使用 `exit()` 函数可以立即终止程序的执行，同时释放程序占用的所有资源，并且不会执行 `exit()` 调用点之后的任何代码。通常情况下，`exit()` 函数用于在程序的主函数 `main()` 或其他函数中执行。

以下是一个示例程序，演示了 `exit()` 函数的基本用法：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int num;

    printf("Enter a number: ");
    scanf("%d", &num);

    if (num < 0) {
        printf("Error: Negative number entered. Exiting program.\n");
        exit(1); // 退出程序并返回非 0 状态
    }

    printf("The square of the number is: %d\n", num * num);

    return 0;
}
```

在这个示例中，如果用户输入的是一个负数，程序将打印出错误信息，并调用 `exit(1)` 终止程序执行，并返回状态码 1。



















